<!doctype html>
<html lang="en">
<head>
<title></title>
<!-- 2017-05-29 mån 04:08 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="arvid">

<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
<style type="text/css">
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<style>body { margin-bottom: 0px; }</style><script type="text/javascript">
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  displayAlign: "center",
  displayIndent: "2em",
  messageStyle: "none",
  "HTML-CSS": {
    scale: 100,
    styles: {
      ".MathJax_Display": {
        "font-size": "100%"
      }
    }
  },
  "SVG": {
    scale: 100,
    styles: {
      ".MathJax_SVG_Display": {
        "font-size": "100%",
        "margin-left": "-2.281em"
      }
    }
  }
});
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"></script>
</head>
<body>
<div id="content" class="container">
<div class="row"><div class="col-md-12"><h1 class="title"></h1>
<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Lärandemål huvudgrupp 1</h2>
<div class="outline-text-2" id="text-">
</div><div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">2017-04-20 (Lärandemål om relevant kunskap i matematik)</h3>
<div class="outline-text-3" id="text-">
<p>
Arbetade med att fastställa koordinater utifrån avstånd till kända punkter. Ofta kallas det triangulering, men om det är sträckor man mätt upp kallas det trilaterering. Det krävs tre kända punkter, härav trilaterering, men om man har två kända punkter får man två möjliga positioner, och det är oftast tillräckligt. Med två avstånd kallas detta bilaterering. Vi har två saker i projektet som behöver detta
</p>
<ul class="org-ul">
<li>Ultraljudslösningen bygger på detta
</li>
<li>När vi mäter upp en bana och lägger ut objekt vill vi veta vilka koordinater dessa har. Enklast är att mäta avstånd från två av våra hörn och bilaterera.
</li>
</ul>
<p>
Min härledning av formeln för bilaterering är denna, <a href="./bilder/Bilateration.jpg">länk till bild</a>. a och c är i härledningen x- och ykoordinater. Jag har även skrivit en funktion i filen koordmapping.py:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">bilateration med tv&#229; k&#228;nda punkter, en i origo och den andra p&#229; y-axeln med avst&#229;nd dist till origo. </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">r1 &#228;r ok&#228;nda punktens avst&#229;nd till origo, r2 avst&#229;nd till andra punkten. </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">Returnerarpositivt x-v&#228;rde, &#228;ven -x &#228;r giltig l&#246;sning</span>
<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">bilat</span><span style="color: #4f97d7;">(</span>dist, r1, r2<span style="color: #4f97d7;">)</span>:
  <span style="color: #7590db;">y</span> = <span style="color: #4f97d7;">(</span>r1**<span style="color: #a45bad;">2</span> - r2**<span style="color: #a45bad;">2</span> + dist**<span style="color: #a45bad;">2</span><span style="color: #4f97d7;">)</span> / <span style="color: #4f97d7;">(</span><span style="color: #a45bad;">2</span> * dist<span style="color: #4f97d7;">)</span>
  <span style="color: #7590db;">x</span> = math.sqrt<span style="color: #4f97d7;">(</span>r1**<span style="color: #a45bad;">2</span> - y**<span style="color: #a45bad;">2</span><span style="color: #4f97d7;">)</span>
  <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #4f97d7;">(</span>x, y<span style="color: #4f97d7;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">Avsnittet Koordinatmappning under Genomförande i rapporten (Lärandemål om relevant kunskap i matematik)</h3>
<div class="outline-text-3" id="text-">
<p>
Avsnittet om Koordinatmappning som jag skrivit i rapporten ger prov på hur jag använt matematiska modeller för att modellera både transformationen mellan pixelkoordinater och världskoordinater, samt matematiskt modellerat det optiska felet i kameran och kompenserat för detta.
</p>
</div>
</div>
<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">2017-05-14 (Lärandemål om UML)</h3>
<div class="outline-text-3" id="text-">
<p>
Jag har gjort två diagram till rapporten som beskriver koordinatmappningen. Det ena är en systembeskrivning, och illustrerar vilka parametrar som krävs för koordinatmappningen. Det andra är ett blockschema som tydligt visar hur programmet kör och vilka steg det tar. Finns i rapporten under Resultat. Länk till <a href="./bilder/Systembeskrivning_coordmapping.png">systembeskrivning</a> och <a href="./bilder/coordmapping_blockschema.png">blockschema</a>
</p>
</div>
</div>
<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">2017-05-18 (Lärandemål om relevant kunskap i matematik)</h3>
<div class="outline-text-3" id="text-">
<p>
Gustaf har tagit fram en kompensation utifrån mätdata från testningen. Vi har kunnat konstatera att det uppstår ett fel längs respektive x- och y-axel, som växer med avståndet från origo. När vi testade med Gustafs kompensation överkompenserade den generellt felet. Jag fick härom dagen en intuition om varför det blir så, och idag översatte jag den intuitionen i formler, och lyckades övertyga Gustaf om att det är en sund matematisk modell. Teorin är följande: Gustafs kompensation kompenserar samtidigt för fel i både x- och y-axel, som om det är två oberoende fel. I min modell av felet beror felet snarare enbart på det diagonala avståndet från origo, och det visar sig något olika i x- och y-led. Det innebär att vi istället för att kompensera i båda led ska göra en kompensation där vi viktar om vi ska kompensera enligt data från x-led eller y-led beroende på hur långt vi befinner oss från origo. Formeln för denna modell är följande för xkoordinaten (något förenklad):
</p>

<p>
\[x_{kompensation} = \frac{x_{fel} \cdot x + y_{fel} \cdot y}{x + y}, x + y \neq 0 \]
</p>

<p>
Detta har jag implementerat i funktionen get_weighted_compensation i coordmapping.py i gitrepot.
</p>
</div>
</div>
</div>
</div></div></div>
</body>
</html>
